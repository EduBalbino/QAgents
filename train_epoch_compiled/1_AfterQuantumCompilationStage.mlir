module @train_epoch_compiled {
  func.func public @jit_train_epoch_compiled(%arg0: tensor<4x8x3xf32>, %arg1: tensor<f32>, %arg2: tensor<f32>, %arg3: tensor<i32>, %arg4: tensor<2xui32>, %arg5: tensor<96x8xf32>, %arg6: tensor<96xf32>, %arg7: tensor<96xf32>) -> (tensor<4x8x3xf32>, tensor<f32>, tensor<f32>, tensor<i32>, tensor<2xui32>, tensor<2xf64>) attributes {llvm.emit_c_interface} {
    %c32 = arith.constant 32 : index
    %c1 = arith.constant 1 : index
    %c3 = arith.constant 3 : index
    %c0 = arith.constant 0 : index
    %cst = stablehlo.constant dense<3.000000e+00> : tensor<f64>
    %cst_0 = stablehlo.constant dense<3.200000e+01> : tensor<f64>
    %c = stablehlo.constant dense<32> : tensor<i64>
    %cst_1 = stablehlo.constant dense<0.000000e+00> : tensor<f32>
    %cst_2 = stablehlo.constant dense<0.000000e+00> : tensor<f64>
    %cst_3 = stablehlo.constant dense<0.00999999977> : tensor<f32>
    %cst_4 = stablehlo.constant dense<3.125000e-02> : tensor<f32>
    %c_5 = stablehlo.constant dense<96> : tensor<i64>
    %c_6 = stablehlo.constant dense<0> : tensor<i64>
    %0 = call @_threefry_split(%arg4) : (tensor<2xui32>) -> tensor<2x2xui32>
    %1 = stablehlo.slice %0 [0:1, 0:2] : (tensor<2x2xui32>) -> tensor<1x2xui32>
    %2 = stablehlo.reshape %1 : (tensor<1x2xui32>) -> tensor<2xui32>
    %3 = stablehlo.slice %0 [1:2, 0:2] : (tensor<2x2xui32>) -> tensor<1x2xui32>
    %4 = stablehlo.reshape %3 : (tensor<1x2xui32>) -> tensor<2xui32>
    %5 = call @_randint(%4, %c_6, %c_5) : (tensor<2xui32>, tensor<i64>, tensor<i64>) -> tensor<i64>
    %6:6 = scf.for %arg8 = %c0 to %c3 step %c1 iter_args(%arg9 = %arg0, %arg10 = %arg1, %arg11 = %arg2, %arg12 = %arg3, %arg13 = %cst_2, %arg14 = %cst_2) -> (tensor<4x8x3xf32>, tensor<f32>, tensor<f32>, tensor<i32>, tensor<f64>, tensor<f64>) {
      %11 = arith.index_cast %arg8 : index to i64
      %from_elements = tensor.from_elements %11 : tensor<i64>
      %12 = stablehlo.broadcast_in_dim %cst_1, dims = [] : (tensor<f32>) -> tensor<4x8x3xf32>
      %13:4 = scf.for %arg15 = %c0 to %c32 step %c1 iter_args(%arg16 = %12, %arg17 = %cst_2, %arg18 = %cst_2, %arg19 = %cst_2) -> (tensor<4x8x3xf32>, tensor<f64>, tensor<f64>, tensor<f64>) {
        %31 = arith.index_cast %arg15 : index to i64
        %from_elements_7 = tensor.from_elements %31 : tensor<i64>
        %32 = stablehlo.multiply %from_elements, %c : tensor<i64>
        %33 = stablehlo.convert %32 : tensor<i64>
        %34 = stablehlo.add %5, %33 : tensor<i64>
        %35 = stablehlo.convert %from_elements_7 : tensor<i64>
        %36 = stablehlo.add %34, %35 : tensor<i64>
        %37 = func.call @remainder(%36, %c_5) : (tensor<i64>, tensor<i64>) -> tensor<i64>
        %38 = stablehlo.compare  LT, %37, %c_6,  SIGNED : (tensor<i64>, tensor<i64>) -> tensor<i1>
        %39 = stablehlo.add %37, %c_5 : tensor<i64>
        %40 = stablehlo.select %38, %39, %37 : tensor<i1>, tensor<i64>
        %41 = stablehlo.dynamic_slice %arg5, %40, %c_6, sizes = [1, 8] : (tensor<96x8xf32>, tensor<i64>, tensor<i64>) -> tensor<1x8xf32>
        %42 = stablehlo.reshape %41 : (tensor<1x8xf32>) -> tensor<8xf32>
        %43 = stablehlo.compare  LT, %37, %c_6,  SIGNED : (tensor<i64>, tensor<i64>) -> tensor<i1>
        %44 = stablehlo.add %37, %c_5 : tensor<i64>
        %45 = stablehlo.select %43, %44, %37 : tensor<i1>, tensor<i64>
        %46 = stablehlo.dynamic_slice %arg6, %45, sizes = [1] : (tensor<96xf32>, tensor<i64>) -> tensor<1xf32>
        %47 = stablehlo.reshape %46 : (tensor<1xf32>) -> tensor<f32>
        %48 = stablehlo.compare  LT, %37, %c_6,  SIGNED : (tensor<i64>, tensor<i64>) -> tensor<i1>
        %49 = stablehlo.add %37, %c_5 : tensor<i64>
        %50 = stablehlo.select %48, %49, %37 : tensor<i1>, tensor<i64>
        %51 = stablehlo.dynamic_slice %arg7, %50, sizes = [1] : (tensor<96xf32>, tensor<i64>) -> tensor<1xf32>
        %52 = stablehlo.reshape %51 : (tensor<1xf32>) -> tensor<f32>
        %53 = func.call @qnode_forward_0(%arg9, %42) : (tensor<4x8x3xf32>, tensor<8xf32>) -> tensor<f64>
        %54 = stablehlo.convert %arg11 : (tensor<f32>) -> tensor<f64>
        %55 = stablehlo.multiply %54, %53 : tensor<f64>
        %56 = stablehlo.convert %arg10 : (tensor<f32>) -> tensor<f64>
        %57 = stablehlo.add %55, %56 : tensor<f64>
        %58 = stablehlo.convert %47 : (tensor<f32>) -> tensor<f64>
        %59 = stablehlo.convert %52 : (tensor<f32>) -> tensor<f64>
        %60 = func.call @softplus(%57) : (tensor<f64>) -> tensor<f64>
        %61 = stablehlo.multiply %58, %57 : tensor<f64>
        %62 = stablehlo.subtract %60, %61 : tensor<f64>
        %63 = stablehlo.multiply %59, %62 : tensor<f64>
        %64:3 = gradient.grad "auto" @_sample_loss(%arg9, %arg10, %arg11, %42, %47, %52) {diffArgIndices = dense<[0, 1, 2]> : tensor<3xi64>} : (tensor<4x8x3xf32>, tensor<f32>, tensor<f32>, tensor<8xf32>, tensor<f32>, tensor<f32>) -> (tensor<4x8x3xf32>, tensor<f32>, tensor<f32>)
        %65 = stablehlo.add %arg16, %64#0 : tensor<4x8x3xf32>
        %66 = stablehlo.convert %64#1 : (tensor<f32>) -> tensor<f64>
        %67 = stablehlo.add %arg17, %66 : tensor<f64>
        %68 = stablehlo.convert %64#2 : (tensor<f32>) -> tensor<f64>
        %69 = stablehlo.add %arg18, %68 : tensor<f64>
        %70 = stablehlo.add %arg19, %63 : tensor<f64>
        scf.yield %65, %67, %69, %70 : tensor<4x8x3xf32>, tensor<f64>, tensor<f64>, tensor<f64>
      }
      %14 = stablehlo.broadcast_in_dim %cst_4, dims = [] : (tensor<f32>) -> tensor<4x8x3xf32>
      %15 = stablehlo.multiply %13#0, %14 : tensor<4x8x3xf32>
      %16 = stablehlo.broadcast_in_dim %cst_3, dims = [] : (tensor<f32>) -> tensor<4x8x3xf32>
      %17 = stablehlo.multiply %16, %15 : tensor<4x8x3xf32>
      %18 = stablehlo.subtract %arg9, %17 : tensor<4x8x3xf32>
      %19 = stablehlo.convert %cst_4 : (tensor<f32>) -> tensor<f64>
      %20 = stablehlo.multiply %13#1, %19 : tensor<f64>
      %21 = stablehlo.convert %20 : (tensor<f64>) -> tensor<f32>
      %22 = stablehlo.multiply %cst_3, %21 : tensor<f32>
      %23 = stablehlo.subtract %arg10, %22 : tensor<f32>
      %24 = stablehlo.convert %cst_4 : (tensor<f32>) -> tensor<f64>
      %25 = stablehlo.multiply %13#2, %24 : tensor<f64>
      %26 = stablehlo.convert %25 : (tensor<f64>) -> tensor<f32>
      %27 = stablehlo.multiply %cst_3, %26 : tensor<f32>
      %28 = stablehlo.subtract %arg11, %27 : tensor<f32>
      %29 = stablehlo.divide %13#3, %cst_0 : tensor<f64>
      %30 = stablehlo.add %arg13, %29 : tensor<f64>
      scf.yield %18, %23, %28, %arg12, %30, %29 : tensor<4x8x3xf32>, tensor<f32>, tensor<f32>, tensor<i32>, tensor<f64>, tensor<f64>
    }
    %7 = stablehlo.divide %6#4, %cst : tensor<f64>
    %8 = stablehlo.broadcast_in_dim %7, dims = [] : (tensor<f64>) -> tensor<1xf64>
    %9 = stablehlo.broadcast_in_dim %6#5, dims = [] : (tensor<f64>) -> tensor<1xf64>
    %10 = stablehlo.concatenate %8, %9, dim = 0 : (tensor<1xf64>, tensor<1xf64>) -> tensor<2xf64>
    return %6#0, %6#1, %6#2, %6#3, %2, %10 : tensor<4x8x3xf32>, tensor<f32>, tensor<f32>, tensor<i32>, tensor<2xui32>, tensor<2xf64>
  }
  func.func private @_threefry_split(%arg0: tensor<2xui32>) -> tensor<2x2xui32> attributes {llvm.linkage = #llvm.linkage<internal>} {
    %c = stablehlo.constant dense<1> : tensor<i64>
    %c_0 = stablehlo.constant dense<5> : tensor<i64>
    %c_1 = stablehlo.constant dense<0> : tensor<i64>
    %c_2 = stablehlo.constant dense<466688986> : tensor<ui32>
    %c_3 = stablehlo.constant dense<[17, 29, 16, 24]> : tensor<4xui32>
    %c_4 = stablehlo.constant dense<[13, 15, 26, 6]> : tensor<4xui32>
    %c_5 = stablehlo.constant dense<32> : tensor<ui64>
    %c_6 = stablehlo.constant dense<1> : tensor<ui64>
    %0 = stablehlo.slice %arg0 [0:1] : (tensor<2xui32>) -> tensor<1xui32>
    %1 = stablehlo.reshape %0 : (tensor<1xui32>) -> tensor<ui32>
    %2 = stablehlo.slice %arg0 [1:2] : (tensor<2xui32>) -> tensor<1xui32>
    %3 = stablehlo.reshape %2 : (tensor<1xui32>) -> tensor<ui32>
    %4 = stablehlo.iota dim = 0 : tensor<2xui64>
    %5 = stablehlo.broadcast_in_dim %c_6, dims = [] : (tensor<ui64>) -> tensor<2xui64>
    %6 = stablehlo.multiply %5, %4 : tensor<2xui64>
    %7 = stablehlo.broadcast_in_dim %c_5, dims = [] : (tensor<ui64>) -> tensor<2xui64>
    %8 = stablehlo.shift_right_logical %6, %7 : tensor<2xui64>
    %9 = stablehlo.convert %6 : (tensor<2xui64>) -> tensor<2xui32>
    %10 = stablehlo.convert %8 : (tensor<2xui64>) -> tensor<2xui32>
    %11 = stablehlo.xor %1, %3 : tensor<ui32>
    %12 = stablehlo.xor %11, %c_2 : tensor<ui32>
    %13 = stablehlo.broadcast_in_dim %1, dims = [] : (tensor<ui32>) -> tensor<2xui32>
    %14 = stablehlo.add %10, %13 : tensor<2xui32>
    %15 = stablehlo.broadcast_in_dim %3, dims = [] : (tensor<ui32>) -> tensor<2xui32>
    %16 = stablehlo.add %9, %15 : tensor<2xui32>
    %17:9 = stablehlo.while(%iterArg = %c_1, %iterArg_7 = %c_1, %iterArg_8 = %14, %iterArg_9 = %16, %iterArg_10 = %3, %iterArg_11 = %12, %iterArg_12 = %1, %iterArg_13 = %c_4, %iterArg_14 = %c_3) : tensor<i64>, tensor<i64>, tensor<2xui32>, tensor<2xui32>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<4xui32>, tensor<4xui32>
    cond {
      %21 = stablehlo.compare  LT, %iterArg, %c_0,  SIGNED : (tensor<i64>, tensor<i64>) -> tensor<i1>
      stablehlo.return %21 : tensor<i1>
    } do {
      %21:8 = func.call @closed_call(%iterArg_7, %iterArg_8, %iterArg_9, %iterArg_10, %iterArg_11, %iterArg_12, %iterArg_13, %iterArg_14) : (tensor<i64>, tensor<2xui32>, tensor<2xui32>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<4xui32>, tensor<4xui32>) -> (tensor<i64>, tensor<2xui32>, tensor<2xui32>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<4xui32>, tensor<4xui32>)
      %22 = stablehlo.add %iterArg, %c : tensor<i64>
      stablehlo.return %22, %21#0, %21#1, %21#2, %21#3, %21#4, %21#5, %21#6, %21#7 : tensor<i64>, tensor<i64>, tensor<2xui32>, tensor<2xui32>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<4xui32>, tensor<4xui32>
    }
    %18 = stablehlo.broadcast_in_dim %17#2, dims = [0] : (tensor<2xui32>) -> tensor<2x1xui32>
    %19 = stablehlo.broadcast_in_dim %17#3, dims = [0] : (tensor<2xui32>) -> tensor<2x1xui32>
    %20 = stablehlo.concatenate %18, %19, dim = 1 : (tensor<2x1xui32>, tensor<2x1xui32>) -> tensor<2x2xui32>
    return %20 : tensor<2x2xui32>
  }
  func.func private @closed_call(%arg0: tensor<i64>, %arg1: tensor<2xui32>, %arg2: tensor<2xui32>, %arg3: tensor<ui32>, %arg4: tensor<ui32>, %arg5: tensor<ui32>, %arg6: tensor<4xui32>, %arg7: tensor<4xui32>) -> (tensor<i64>, tensor<2xui32>, tensor<2xui32>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<4xui32>, tensor<4xui32>) attributes {llvm.linkage = #llvm.linkage<internal>} {
    %c = stablehlo.constant dense<32> : tensor<ui32>
    %c_0 = stablehlo.constant dense<1> : tensor<i64>
    %0 = stablehlo.add %arg0, %c_0 : tensor<i64>
    %1 = stablehlo.slice %arg6 [0:1] : (tensor<4xui32>) -> tensor<1xui32>
    %2 = stablehlo.reshape %1 : (tensor<1xui32>) -> tensor<ui32>
    %3 = stablehlo.add %arg1, %arg2 : tensor<2xui32>
    %4 = stablehlo.broadcast_in_dim %2, dims = [] : (tensor<ui32>) -> tensor<2xui32>
    %5 = stablehlo.shift_left %arg2, %4 : tensor<2xui32>
    %6 = stablehlo.subtract %c, %2 : tensor<ui32>
    %7 = stablehlo.broadcast_in_dim %6, dims = [] : (tensor<ui32>) -> tensor<2xui32>
    %8 = stablehlo.shift_right_logical %arg2, %7 : tensor<2xui32>
    %9 = stablehlo.or %5, %8 : tensor<2xui32>
    %10 = stablehlo.xor %3, %9 : tensor<2xui32>
    %11 = stablehlo.slice %arg6 [1:2] : (tensor<4xui32>) -> tensor<1xui32>
    %12 = stablehlo.reshape %11 : (tensor<1xui32>) -> tensor<ui32>
    %13 = stablehlo.add %3, %10 : tensor<2xui32>
    %14 = stablehlo.broadcast_in_dim %12, dims = [] : (tensor<ui32>) -> tensor<2xui32>
    %15 = stablehlo.shift_left %10, %14 : tensor<2xui32>
    %16 = stablehlo.subtract %c, %12 : tensor<ui32>
    %17 = stablehlo.broadcast_in_dim %16, dims = [] : (tensor<ui32>) -> tensor<2xui32>
    %18 = stablehlo.shift_right_logical %10, %17 : tensor<2xui32>
    %19 = stablehlo.or %15, %18 : tensor<2xui32>
    %20 = stablehlo.xor %13, %19 : tensor<2xui32>
    %21 = stablehlo.slice %arg6 [2:3] : (tensor<4xui32>) -> tensor<1xui32>
    %22 = stablehlo.reshape %21 : (tensor<1xui32>) -> tensor<ui32>
    %23 = stablehlo.add %13, %20 : tensor<2xui32>
    %24 = stablehlo.broadcast_in_dim %22, dims = [] : (tensor<ui32>) -> tensor<2xui32>
    %25 = stablehlo.shift_left %20, %24 : tensor<2xui32>
    %26 = stablehlo.subtract %c, %22 : tensor<ui32>
    %27 = stablehlo.broadcast_in_dim %26, dims = [] : (tensor<ui32>) -> tensor<2xui32>
    %28 = stablehlo.shift_right_logical %20, %27 : tensor<2xui32>
    %29 = stablehlo.or %25, %28 : tensor<2xui32>
    %30 = stablehlo.xor %23, %29 : tensor<2xui32>
    %31 = stablehlo.slice %arg6 [3:4] : (tensor<4xui32>) -> tensor<1xui32>
    %32 = stablehlo.reshape %31 : (tensor<1xui32>) -> tensor<ui32>
    %33 = stablehlo.add %23, %30 : tensor<2xui32>
    %34 = stablehlo.broadcast_in_dim %32, dims = [] : (tensor<ui32>) -> tensor<2xui32>
    %35 = stablehlo.shift_left %30, %34 : tensor<2xui32>
    %36 = stablehlo.subtract %c, %32 : tensor<ui32>
    %37 = stablehlo.broadcast_in_dim %36, dims = [] : (tensor<ui32>) -> tensor<2xui32>
    %38 = stablehlo.shift_right_logical %30, %37 : tensor<2xui32>
    %39 = stablehlo.or %35, %38 : tensor<2xui32>
    %40 = stablehlo.xor %33, %39 : tensor<2xui32>
    %41 = stablehlo.broadcast_in_dim %arg3, dims = [] : (tensor<ui32>) -> tensor<2xui32>
    %42 = stablehlo.add %33, %41 : tensor<2xui32>
    %43 = stablehlo.broadcast_in_dim %arg4, dims = [] : (tensor<ui32>) -> tensor<2xui32>
    %44 = stablehlo.add %40, %43 : tensor<2xui32>
    %45 = stablehlo.add %arg0, %c_0 : tensor<i64>
    %46 = stablehlo.convert %45 : (tensor<i64>) -> tensor<ui32>
    %47 = stablehlo.broadcast_in_dim %46, dims = [] : (tensor<ui32>) -> tensor<2xui32>
    %48 = stablehlo.add %44, %47 : tensor<2xui32>
    return %0, %42, %48, %arg4, %arg5, %arg3, %arg7, %arg6 : tensor<i64>, tensor<2xui32>, tensor<2xui32>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<4xui32>, tensor<4xui32>
  }
  func.func private @_randint(%arg0: tensor<2xui32>, %arg1: tensor<i64>, %arg2: tensor<i64>) -> tensor<i64> attributes {llvm.linkage = #llvm.linkage<internal>} {
    %c = stablehlo.constant dense<4294967296> : tensor<ui64>
    %c_0 = stablehlo.constant dense<1> : tensor<ui64>
    %c_1 = stablehlo.constant dense<32> : tensor<ui64>
    %c_2 = stablehlo.constant dense<1> : tensor<i64>
    %c_3 = stablehlo.constant dense<5> : tensor<i64>
    %c_4 = stablehlo.constant dense<0> : tensor<i64>
    %c_5 = stablehlo.constant dense<466688986> : tensor<ui32>
    %c_6 = stablehlo.constant dense<[17, 29, 16, 24]> : tensor<4xui32>
    %c_7 = stablehlo.constant dense<[13, 15, 26, 6]> : tensor<4xui32>
    %c_8 = stablehlo.constant dense<0> : tensor<ui32>
    %c_9 = stablehlo.constant dense<9223372036854775807> : tensor<i64>
    %c_10 = stablehlo.constant dense<-9223372036854775808> : tensor<i64>
    %0 = call @clip(%c_9, %c_10, %c_9) : (tensor<i64>, tensor<i64>, tensor<i64>) -> tensor<i64>
    %1 = stablehlo.compare  GT, %arg2, %0,  SIGNED : (tensor<i64>, tensor<i64>) -> tensor<i1>
    %2 = call @clip_0(%arg1, %c_10, %c_9) : (tensor<i64>, tensor<i64>, tensor<i64>) -> tensor<i64>
    %3 = stablehlo.convert %2 : tensor<i64>
    %4 = call @clip_0(%arg2, %c_10, %c_9) : (tensor<i64>, tensor<i64>, tensor<i64>) -> tensor<i64>
    %5 = stablehlo.convert %4 : tensor<i64>
    %6 = call @_threefry_split(%arg0) : (tensor<2xui32>) -> tensor<2x2xui32>
    %7 = stablehlo.slice %6 [0:1, 0:2] : (tensor<2x2xui32>) -> tensor<1x2xui32>
    %8 = stablehlo.reshape %7 : (tensor<1x2xui32>) -> tensor<2xui32>
    %9 = stablehlo.slice %6 [1:2, 0:2] : (tensor<2x2xui32>) -> tensor<1x2xui32>
    %10 = stablehlo.reshape %9 : (tensor<1x2xui32>) -> tensor<2xui32>
    %11 = stablehlo.slice %8 [0:1] : (tensor<2xui32>) -> tensor<1xui32>
    %12 = stablehlo.reshape %11 : (tensor<1xui32>) -> tensor<ui32>
    %13 = stablehlo.slice %8 [1:2] : (tensor<2xui32>) -> tensor<1xui32>
    %14 = stablehlo.reshape %13 : (tensor<1xui32>) -> tensor<ui32>
    %15 = stablehlo.xor %12, %14 : tensor<ui32>
    %16 = stablehlo.xor %15, %c_5 : tensor<ui32>
    %17 = stablehlo.add %c_8, %12 : tensor<ui32>
    %18 = stablehlo.add %c_8, %14 : tensor<ui32>
    %19:9 = stablehlo.while(%iterArg = %c_4, %iterArg_11 = %c_4, %iterArg_12 = %17, %iterArg_13 = %18, %iterArg_14 = %14, %iterArg_15 = %16, %iterArg_16 = %12, %iterArg_17 = %c_7, %iterArg_18 = %c_6) : tensor<i64>, tensor<i64>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<4xui32>, tensor<4xui32>
    cond {
      %55 = stablehlo.compare  LT, %iterArg, %c_3,  SIGNED : (tensor<i64>, tensor<i64>) -> tensor<i1>
      stablehlo.return %55 : tensor<i1>
    } do {
      %55:8 = func.call @closed_call_1(%iterArg_11, %iterArg_12, %iterArg_13, %iterArg_14, %iterArg_15, %iterArg_16, %iterArg_17, %iterArg_18) : (tensor<i64>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<4xui32>, tensor<4xui32>) -> (tensor<i64>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<4xui32>, tensor<4xui32>)
      %56 = stablehlo.add %iterArg, %c_2 : tensor<i64>
      stablehlo.return %56, %55#0, %55#1, %55#2, %55#3, %55#4, %55#5, %55#6, %55#7 : tensor<i64>, tensor<i64>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<4xui32>, tensor<4xui32>
    }
    %20 = stablehlo.convert %19#2 : (tensor<ui32>) -> tensor<ui64>
    %21 = stablehlo.convert %19#3 : (tensor<ui32>) -> tensor<ui64>
    %22 = stablehlo.shift_left %20, %c_1 : tensor<ui64>
    %23 = stablehlo.or %22, %21 : tensor<ui64>
    %24 = stablehlo.slice %10 [0:1] : (tensor<2xui32>) -> tensor<1xui32>
    %25 = stablehlo.reshape %24 : (tensor<1xui32>) -> tensor<ui32>
    %26 = stablehlo.slice %10 [1:2] : (tensor<2xui32>) -> tensor<1xui32>
    %27 = stablehlo.reshape %26 : (tensor<1xui32>) -> tensor<ui32>
    %28 = stablehlo.xor %25, %27 : tensor<ui32>
    %29 = stablehlo.xor %28, %c_5 : tensor<ui32>
    %30 = stablehlo.add %c_8, %25 : tensor<ui32>
    %31 = stablehlo.add %c_8, %27 : tensor<ui32>
    %32:9 = stablehlo.while(%iterArg = %c_4, %iterArg_11 = %c_4, %iterArg_12 = %30, %iterArg_13 = %31, %iterArg_14 = %27, %iterArg_15 = %29, %iterArg_16 = %25, %iterArg_17 = %c_7, %iterArg_18 = %c_6) : tensor<i64>, tensor<i64>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<4xui32>, tensor<4xui32>
    cond {
      %55 = stablehlo.compare  LT, %iterArg, %c_3,  SIGNED : (tensor<i64>, tensor<i64>) -> tensor<i1>
      stablehlo.return %55 : tensor<i1>
    } do {
      %55:8 = func.call @closed_call_1(%iterArg_11, %iterArg_12, %iterArg_13, %iterArg_14, %iterArg_15, %iterArg_16, %iterArg_17, %iterArg_18) : (tensor<i64>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<4xui32>, tensor<4xui32>) -> (tensor<i64>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<4xui32>, tensor<4xui32>)
      %56 = stablehlo.add %iterArg, %c_2 : tensor<i64>
      stablehlo.return %56, %55#0, %55#1, %55#2, %55#3, %55#4, %55#5, %55#6, %55#7 : tensor<i64>, tensor<i64>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<4xui32>, tensor<4xui32>
    }
    %33 = stablehlo.convert %32#2 : (tensor<ui32>) -> tensor<ui64>
    %34 = stablehlo.convert %32#3 : (tensor<ui32>) -> tensor<ui64>
    %35 = stablehlo.shift_left %33, %c_1 : tensor<ui64>
    %36 = stablehlo.or %35, %34 : tensor<ui64>
    %37 = stablehlo.subtract %5, %3 : tensor<i64>
    %38 = stablehlo.convert %37 : (tensor<i64>) -> tensor<ui64>
    %39 = stablehlo.compare  LE, %5, %3,  SIGNED : (tensor<i64>, tensor<i64>) -> tensor<i1>
    %40 = stablehlo.select %39, %c_0, %38 : tensor<i1>, tensor<ui64>
    %41 = stablehlo.compare  GT, %5, %3,  SIGNED : (tensor<i64>, tensor<i64>) -> tensor<i1>
    %42 = stablehlo.and %1, %41 : tensor<i1>
    %43 = stablehlo.add %40, %c_0 : tensor<ui64>
    %44 = stablehlo.select %42, %43, %40 : tensor<i1>, tensor<ui64>
    %45 = stablehlo.remainder %c, %44 : tensor<ui64>
    %46 = stablehlo.multiply %45, %45 : tensor<ui64>
    %47 = stablehlo.remainder %46, %44 : tensor<ui64>
    %48 = stablehlo.remainder %23, %44 : tensor<ui64>
    %49 = stablehlo.multiply %48, %47 : tensor<ui64>
    %50 = stablehlo.remainder %36, %44 : tensor<ui64>
    %51 = stablehlo.add %49, %50 : tensor<ui64>
    %52 = stablehlo.remainder %51, %44 : tensor<ui64>
    %53 = stablehlo.convert %52 : (tensor<ui64>) -> tensor<i64>
    %54 = stablehlo.add %3, %53 : tensor<i64>
    return %54 : tensor<i64>
  }
  func.func private @clip(%arg0: tensor<i64>, %arg1: tensor<i64>, %arg2: tensor<i64>) -> tensor<i64> attributes {llvm.linkage = #llvm.linkage<internal>} {
    %0 = stablehlo.maximum %arg1, %arg0 : tensor<i64>
    %1 = stablehlo.minimum %arg2, %0 : tensor<i64>
    return %1 : tensor<i64>
  }
  func.func private @clip_0(%arg0: tensor<i64>, %arg1: tensor<i64>, %arg2: tensor<i64>) -> tensor<i64> attributes {llvm.linkage = #llvm.linkage<internal>} {
    %0 = stablehlo.maximum %arg1, %arg0 : tensor<i64>
    %1 = stablehlo.minimum %arg2, %0 : tensor<i64>
    return %1 : tensor<i64>
  }
  func.func private @closed_call_1(%arg0: tensor<i64>, %arg1: tensor<ui32>, %arg2: tensor<ui32>, %arg3: tensor<ui32>, %arg4: tensor<ui32>, %arg5: tensor<ui32>, %arg6: tensor<4xui32>, %arg7: tensor<4xui32>) -> (tensor<i64>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<4xui32>, tensor<4xui32>) attributes {llvm.linkage = #llvm.linkage<internal>} {
    %c = stablehlo.constant dense<32> : tensor<ui32>
    %c_0 = stablehlo.constant dense<1> : tensor<i64>
    %0 = stablehlo.add %arg0, %c_0 : tensor<i64>
    %1 = stablehlo.slice %arg6 [0:1] : (tensor<4xui32>) -> tensor<1xui32>
    %2 = stablehlo.reshape %1 : (tensor<1xui32>) -> tensor<ui32>
    %3 = stablehlo.add %arg1, %arg2 : tensor<ui32>
    %4 = stablehlo.shift_left %arg2, %2 : tensor<ui32>
    %5 = stablehlo.subtract %c, %2 : tensor<ui32>
    %6 = stablehlo.shift_right_logical %arg2, %5 : tensor<ui32>
    %7 = stablehlo.or %4, %6 : tensor<ui32>
    %8 = stablehlo.xor %3, %7 : tensor<ui32>
    %9 = stablehlo.slice %arg6 [1:2] : (tensor<4xui32>) -> tensor<1xui32>
    %10 = stablehlo.reshape %9 : (tensor<1xui32>) -> tensor<ui32>
    %11 = stablehlo.add %3, %8 : tensor<ui32>
    %12 = stablehlo.shift_left %8, %10 : tensor<ui32>
    %13 = stablehlo.subtract %c, %10 : tensor<ui32>
    %14 = stablehlo.shift_right_logical %8, %13 : tensor<ui32>
    %15 = stablehlo.or %12, %14 : tensor<ui32>
    %16 = stablehlo.xor %11, %15 : tensor<ui32>
    %17 = stablehlo.slice %arg6 [2:3] : (tensor<4xui32>) -> tensor<1xui32>
    %18 = stablehlo.reshape %17 : (tensor<1xui32>) -> tensor<ui32>
    %19 = stablehlo.add %11, %16 : tensor<ui32>
    %20 = stablehlo.shift_left %16, %18 : tensor<ui32>
    %21 = stablehlo.subtract %c, %18 : tensor<ui32>
    %22 = stablehlo.shift_right_logical %16, %21 : tensor<ui32>
    %23 = stablehlo.or %20, %22 : tensor<ui32>
    %24 = stablehlo.xor %19, %23 : tensor<ui32>
    %25 = stablehlo.slice %arg6 [3:4] : (tensor<4xui32>) -> tensor<1xui32>
    %26 = stablehlo.reshape %25 : (tensor<1xui32>) -> tensor<ui32>
    %27 = stablehlo.add %19, %24 : tensor<ui32>
    %28 = stablehlo.shift_left %24, %26 : tensor<ui32>
    %29 = stablehlo.subtract %c, %26 : tensor<ui32>
    %30 = stablehlo.shift_right_logical %24, %29 : tensor<ui32>
    %31 = stablehlo.or %28, %30 : tensor<ui32>
    %32 = stablehlo.xor %27, %31 : tensor<ui32>
    %33 = stablehlo.add %27, %arg3 : tensor<ui32>
    %34 = stablehlo.add %32, %arg4 : tensor<ui32>
    %35 = stablehlo.add %arg0, %c_0 : tensor<i64>
    %36 = stablehlo.convert %35 : (tensor<i64>) -> tensor<ui32>
    %37 = stablehlo.add %34, %36 : tensor<ui32>
    return %0, %33, %37, %arg4, %arg5, %arg3, %arg7, %arg6 : tensor<i64>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<ui32>, tensor<4xui32>, tensor<4xui32>
  }
  func.func private @remainder(%arg0: tensor<i64>, %arg1: tensor<i64>) -> tensor<i64> attributes {llvm.linkage = #llvm.linkage<internal>} {
    %c = stablehlo.constant dense<1> : tensor<i64>
    %c_0 = stablehlo.constant dense<0> : tensor<i64>
    %0 = stablehlo.convert %arg1 : tensor<i64>
    %1 = stablehlo.compare  EQ, %0, %c_0,  SIGNED : (tensor<i64>, tensor<i64>) -> tensor<i1>
    %2 = call @_where(%1, %c, %0) : (tensor<i1>, tensor<i64>, tensor<i64>) -> tensor<i64>
    %3 = stablehlo.remainder %arg0, %2 : tensor<i64>
    %4 = stablehlo.compare  NE, %3, %c_0,  SIGNED : (tensor<i64>, tensor<i64>) -> tensor<i1>
    %5 = stablehlo.compare  LT, %3, %c_0,  SIGNED : (tensor<i64>, tensor<i64>) -> tensor<i1>
    %6 = stablehlo.compare  LT, %2, %c_0,  SIGNED : (tensor<i64>, tensor<i64>) -> tensor<i1>
    %7 = stablehlo.compare  NE, %5, %6,  UNSIGNED : (tensor<i1>, tensor<i1>) -> tensor<i1>
    %8 = stablehlo.and %7, %4 : tensor<i1>
    %9 = stablehlo.add %3, %2 : tensor<i64>
    %10 = stablehlo.select %8, %9, %3 : tensor<i1>, tensor<i64>
    return %10 : tensor<i64>
  }
  func.func private @_where(%arg0: tensor<i1>, %arg1: tensor<i64>, %arg2: tensor<i64>) -> tensor<i64> attributes {llvm.linkage = #llvm.linkage<internal>} {
    %0 = stablehlo.select %arg0, %arg1, %arg2 : tensor<i1>, tensor<i64>
    return %0 : tensor<i64>
  }
  func.func public @qnode_forward_0(%arg0: tensor<4x8x3xf32>, %arg1: tensor<8xf32>) -> tensor<f64> attributes {diff_method = "adjoint", llvm.linkage = #llvm.linkage<internal>, qnode} {
    %c0_i64 = arith.constant 0 : i64
    %cst = stablehlo.constant dense<3.14159274> : tensor<f32>
    %0 = stablehlo.slice %arg0 [3:4, 0:1, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %1 = stablehlo.reshape %0 : (tensor<1x1x1xf32>) -> tensor<f32>
    %2 = stablehlo.slice %arg0 [3:4, 0:1, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %3 = stablehlo.reshape %2 : (tensor<1x1x1xf32>) -> tensor<f32>
    %4 = stablehlo.slice %arg0 [3:4, 0:1, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %5 = stablehlo.reshape %4 : (tensor<1x1x1xf32>) -> tensor<f32>
    %6 = stablehlo.slice %arg0 [2:3, 0:1, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %7 = stablehlo.reshape %6 : (tensor<1x1x1xf32>) -> tensor<f32>
    %8 = stablehlo.slice %arg0 [2:3, 0:1, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %9 = stablehlo.reshape %8 : (tensor<1x1x1xf32>) -> tensor<f32>
    %10 = stablehlo.slice %arg0 [2:3, 0:1, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %11 = stablehlo.reshape %10 : (tensor<1x1x1xf32>) -> tensor<f32>
    %12 = stablehlo.slice %arg0 [1:2, 6:7, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %13 = stablehlo.reshape %12 : (tensor<1x1x1xf32>) -> tensor<f32>
    %14 = stablehlo.slice %arg0 [1:2, 6:7, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %15 = stablehlo.reshape %14 : (tensor<1x1x1xf32>) -> tensor<f32>
    %16 = stablehlo.slice %arg0 [1:2, 6:7, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %17 = stablehlo.reshape %16 : (tensor<1x1x1xf32>) -> tensor<f32>
    %18 = stablehlo.slice %arg0 [0:1, 7:8, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %19 = stablehlo.reshape %18 : (tensor<1x1x1xf32>) -> tensor<f32>
    %20 = stablehlo.slice %arg0 [0:1, 7:8, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %21 = stablehlo.reshape %20 : (tensor<1x1x1xf32>) -> tensor<f32>
    %22 = stablehlo.slice %arg0 [0:1, 7:8, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %23 = stablehlo.reshape %22 : (tensor<1x1x1xf32>) -> tensor<f32>
    %24 = stablehlo.broadcast_in_dim %cst, dims = [] : (tensor<f32>) -> tensor<8xf32>
    %25 = stablehlo.multiply %24, %arg1 : tensor<8xf32>
    %26 = stablehlo.slice %25 [7:8] : (tensor<8xf32>) -> tensor<1xf32>
    %27 = stablehlo.reshape %26 : (tensor<1xf32>) -> tensor<f32>
    quantum.device shots(%c0_i64) ["/home/pichau/QAgents/.venv/lib/python3.12/site-packages/pennylane_lightning/liblightning_qubit_catalyst.so", "LightningSimulator", "{'mcmc': False, 'num_burnin': 0, 'kernel_name': None}"]
    %28 = quantum.alloc( 8) : !quantum.reg
    %29 = quantum.extract %28[ 7] : !quantum.reg -> !quantum.bit
    %30 = stablehlo.convert %27 : (tensor<f32>) -> tensor<f64>
    %extracted = tensor.extract %30[] : tensor<f64>
    %out_qubits = quantum.custom "RY"(%extracted) %29 : !quantum.bit
    %31 = stablehlo.convert %23 : (tensor<f32>) -> tensor<f64>
    %extracted_0 = tensor.extract %31[] : tensor<f64>
    %out_qubits_1 = quantum.custom "RZ"(%extracted_0) %out_qubits : !quantum.bit
    %32 = stablehlo.convert %21 : (tensor<f32>) -> tensor<f64>
    %extracted_2 = tensor.extract %32[] : tensor<f64>
    %out_qubits_3 = quantum.custom "RY"(%extracted_2) %out_qubits_1 : !quantum.bit
    %33 = stablehlo.convert %19 : (tensor<f32>) -> tensor<f64>
    %extracted_4 = tensor.extract %33[] : tensor<f64>
    %out_qubits_5 = quantum.custom "RZ"(%extracted_4) %out_qubits_3 : !quantum.bit
    %34 = stablehlo.slice %arg0 [0:1, 6:7, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %35 = stablehlo.reshape %34 : (tensor<1x1x1xf32>) -> tensor<f32>
    %36 = stablehlo.slice %arg0 [0:1, 6:7, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %37 = stablehlo.reshape %36 : (tensor<1x1x1xf32>) -> tensor<f32>
    %38 = stablehlo.slice %arg0 [0:1, 6:7, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %39 = stablehlo.reshape %38 : (tensor<1x1x1xf32>) -> tensor<f32>
    %40 = stablehlo.slice %25 [6:7] : (tensor<8xf32>) -> tensor<1xf32>
    %41 = stablehlo.reshape %40 : (tensor<1xf32>) -> tensor<f32>
    %42 = quantum.extract %28[ 6] : !quantum.reg -> !quantum.bit
    %43 = stablehlo.convert %41 : (tensor<f32>) -> tensor<f64>
    %extracted_6 = tensor.extract %43[] : tensor<f64>
    %out_qubits_7 = quantum.custom "RY"(%extracted_6) %42 : !quantum.bit
    %44 = stablehlo.convert %39 : (tensor<f32>) -> tensor<f64>
    %extracted_8 = tensor.extract %44[] : tensor<f64>
    %out_qubits_9 = quantum.custom "RZ"(%extracted_8) %out_qubits_7 : !quantum.bit
    %45 = stablehlo.convert %37 : (tensor<f32>) -> tensor<f64>
    %extracted_10 = tensor.extract %45[] : tensor<f64>
    %out_qubits_11 = quantum.custom "RY"(%extracted_10) %out_qubits_9 : !quantum.bit
    %46 = stablehlo.convert %35 : (tensor<f32>) -> tensor<f64>
    %extracted_12 = tensor.extract %46[] : tensor<f64>
    %out_qubits_13 = quantum.custom "RZ"(%extracted_12) %out_qubits_11 : !quantum.bit
    %47 = stablehlo.slice %arg0 [0:1, 5:6, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %48 = stablehlo.reshape %47 : (tensor<1x1x1xf32>) -> tensor<f32>
    %49 = stablehlo.slice %arg0 [0:1, 5:6, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %50 = stablehlo.reshape %49 : (tensor<1x1x1xf32>) -> tensor<f32>
    %51 = stablehlo.slice %arg0 [0:1, 5:6, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %52 = stablehlo.reshape %51 : (tensor<1x1x1xf32>) -> tensor<f32>
    %53 = stablehlo.slice %25 [5:6] : (tensor<8xf32>) -> tensor<1xf32>
    %54 = stablehlo.reshape %53 : (tensor<1xf32>) -> tensor<f32>
    %55 = quantum.extract %28[ 5] : !quantum.reg -> !quantum.bit
    %56 = stablehlo.convert %54 : (tensor<f32>) -> tensor<f64>
    %extracted_14 = tensor.extract %56[] : tensor<f64>
    %out_qubits_15 = quantum.custom "RY"(%extracted_14) %55 : !quantum.bit
    %57 = stablehlo.convert %52 : (tensor<f32>) -> tensor<f64>
    %extracted_16 = tensor.extract %57[] : tensor<f64>
    %out_qubits_17 = quantum.custom "RZ"(%extracted_16) %out_qubits_15 : !quantum.bit
    %58 = stablehlo.convert %50 : (tensor<f32>) -> tensor<f64>
    %extracted_18 = tensor.extract %58[] : tensor<f64>
    %out_qubits_19 = quantum.custom "RY"(%extracted_18) %out_qubits_17 : !quantum.bit
    %59 = stablehlo.convert %48 : (tensor<f32>) -> tensor<f64>
    %extracted_20 = tensor.extract %59[] : tensor<f64>
    %out_qubits_21 = quantum.custom "RZ"(%extracted_20) %out_qubits_19 : !quantum.bit
    %60 = stablehlo.slice %arg0 [0:1, 4:5, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %61 = stablehlo.reshape %60 : (tensor<1x1x1xf32>) -> tensor<f32>
    %62 = stablehlo.slice %arg0 [0:1, 4:5, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %63 = stablehlo.reshape %62 : (tensor<1x1x1xf32>) -> tensor<f32>
    %64 = stablehlo.slice %arg0 [0:1, 4:5, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %65 = stablehlo.reshape %64 : (tensor<1x1x1xf32>) -> tensor<f32>
    %66 = stablehlo.slice %25 [4:5] : (tensor<8xf32>) -> tensor<1xf32>
    %67 = stablehlo.reshape %66 : (tensor<1xf32>) -> tensor<f32>
    %68 = quantum.extract %28[ 4] : !quantum.reg -> !quantum.bit
    %69 = stablehlo.convert %67 : (tensor<f32>) -> tensor<f64>
    %extracted_22 = tensor.extract %69[] : tensor<f64>
    %out_qubits_23 = quantum.custom "RY"(%extracted_22) %68 : !quantum.bit
    %70 = stablehlo.convert %65 : (tensor<f32>) -> tensor<f64>
    %extracted_24 = tensor.extract %70[] : tensor<f64>
    %out_qubits_25 = quantum.custom "RZ"(%extracted_24) %out_qubits_23 : !quantum.bit
    %71 = stablehlo.convert %63 : (tensor<f32>) -> tensor<f64>
    %extracted_26 = tensor.extract %71[] : tensor<f64>
    %out_qubits_27 = quantum.custom "RY"(%extracted_26) %out_qubits_25 : !quantum.bit
    %72 = stablehlo.convert %61 : (tensor<f32>) -> tensor<f64>
    %extracted_28 = tensor.extract %72[] : tensor<f64>
    %out_qubits_29 = quantum.custom "RZ"(%extracted_28) %out_qubits_27 : !quantum.bit
    %73 = stablehlo.slice %arg0 [0:1, 3:4, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %74 = stablehlo.reshape %73 : (tensor<1x1x1xf32>) -> tensor<f32>
    %75 = stablehlo.slice %arg0 [0:1, 3:4, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %76 = stablehlo.reshape %75 : (tensor<1x1x1xf32>) -> tensor<f32>
    %77 = stablehlo.slice %arg0 [0:1, 3:4, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %78 = stablehlo.reshape %77 : (tensor<1x1x1xf32>) -> tensor<f32>
    %79 = stablehlo.slice %25 [3:4] : (tensor<8xf32>) -> tensor<1xf32>
    %80 = stablehlo.reshape %79 : (tensor<1xf32>) -> tensor<f32>
    %81 = quantum.extract %28[ 3] : !quantum.reg -> !quantum.bit
    %82 = stablehlo.convert %80 : (tensor<f32>) -> tensor<f64>
    %extracted_30 = tensor.extract %82[] : tensor<f64>
    %out_qubits_31 = quantum.custom "RY"(%extracted_30) %81 : !quantum.bit
    %83 = stablehlo.convert %78 : (tensor<f32>) -> tensor<f64>
    %extracted_32 = tensor.extract %83[] : tensor<f64>
    %out_qubits_33 = quantum.custom "RZ"(%extracted_32) %out_qubits_31 : !quantum.bit
    %84 = stablehlo.convert %76 : (tensor<f32>) -> tensor<f64>
    %extracted_34 = tensor.extract %84[] : tensor<f64>
    %out_qubits_35 = quantum.custom "RY"(%extracted_34) %out_qubits_33 : !quantum.bit
    %85 = stablehlo.convert %74 : (tensor<f32>) -> tensor<f64>
    %extracted_36 = tensor.extract %85[] : tensor<f64>
    %out_qubits_37 = quantum.custom "RZ"(%extracted_36) %out_qubits_35 : !quantum.bit
    %86 = stablehlo.slice %arg0 [0:1, 2:3, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %87 = stablehlo.reshape %86 : (tensor<1x1x1xf32>) -> tensor<f32>
    %88 = stablehlo.slice %arg0 [0:1, 2:3, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %89 = stablehlo.reshape %88 : (tensor<1x1x1xf32>) -> tensor<f32>
    %90 = stablehlo.slice %arg0 [0:1, 2:3, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %91 = stablehlo.reshape %90 : (tensor<1x1x1xf32>) -> tensor<f32>
    %92 = stablehlo.slice %25 [2:3] : (tensor<8xf32>) -> tensor<1xf32>
    %93 = stablehlo.reshape %92 : (tensor<1xf32>) -> tensor<f32>
    %94 = quantum.extract %28[ 2] : !quantum.reg -> !quantum.bit
    %95 = stablehlo.convert %93 : (tensor<f32>) -> tensor<f64>
    %extracted_38 = tensor.extract %95[] : tensor<f64>
    %out_qubits_39 = quantum.custom "RY"(%extracted_38) %94 : !quantum.bit
    %96 = stablehlo.convert %91 : (tensor<f32>) -> tensor<f64>
    %extracted_40 = tensor.extract %96[] : tensor<f64>
    %out_qubits_41 = quantum.custom "RZ"(%extracted_40) %out_qubits_39 : !quantum.bit
    %97 = stablehlo.convert %89 : (tensor<f32>) -> tensor<f64>
    %extracted_42 = tensor.extract %97[] : tensor<f64>
    %out_qubits_43 = quantum.custom "RY"(%extracted_42) %out_qubits_41 : !quantum.bit
    %98 = stablehlo.convert %87 : (tensor<f32>) -> tensor<f64>
    %extracted_44 = tensor.extract %98[] : tensor<f64>
    %out_qubits_45 = quantum.custom "RZ"(%extracted_44) %out_qubits_43 : !quantum.bit
    %99 = stablehlo.slice %arg0 [0:1, 0:1, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %100 = stablehlo.reshape %99 : (tensor<1x1x1xf32>) -> tensor<f32>
    %101 = stablehlo.slice %arg0 [0:1, 0:1, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %102 = stablehlo.reshape %101 : (tensor<1x1x1xf32>) -> tensor<f32>
    %103 = stablehlo.slice %arg0 [0:1, 0:1, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %104 = stablehlo.reshape %103 : (tensor<1x1x1xf32>) -> tensor<f32>
    %105 = stablehlo.slice %25 [0:1] : (tensor<8xf32>) -> tensor<1xf32>
    %106 = stablehlo.reshape %105 : (tensor<1xf32>) -> tensor<f32>
    %107 = quantum.extract %28[ 0] : !quantum.reg -> !quantum.bit
    %108 = stablehlo.convert %106 : (tensor<f32>) -> tensor<f64>
    %extracted_46 = tensor.extract %108[] : tensor<f64>
    %out_qubits_47 = quantum.custom "RY"(%extracted_46) %107 : !quantum.bit
    %109 = stablehlo.convert %104 : (tensor<f32>) -> tensor<f64>
    %extracted_48 = tensor.extract %109[] : tensor<f64>
    %out_qubits_49 = quantum.custom "RZ"(%extracted_48) %out_qubits_47 : !quantum.bit
    %110 = stablehlo.convert %102 : (tensor<f32>) -> tensor<f64>
    %extracted_50 = tensor.extract %110[] : tensor<f64>
    %out_qubits_51 = quantum.custom "RY"(%extracted_50) %out_qubits_49 : !quantum.bit
    %111 = stablehlo.convert %100 : (tensor<f32>) -> tensor<f64>
    %extracted_52 = tensor.extract %111[] : tensor<f64>
    %out_qubits_53 = quantum.custom "RZ"(%extracted_52) %out_qubits_51 : !quantum.bit
    %112 = stablehlo.slice %arg0 [0:1, 1:2, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %113 = stablehlo.reshape %112 : (tensor<1x1x1xf32>) -> tensor<f32>
    %114 = stablehlo.slice %arg0 [0:1, 1:2, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %115 = stablehlo.reshape %114 : (tensor<1x1x1xf32>) -> tensor<f32>
    %116 = stablehlo.slice %arg0 [0:1, 1:2, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %117 = stablehlo.reshape %116 : (tensor<1x1x1xf32>) -> tensor<f32>
    %118 = stablehlo.slice %25 [1:2] : (tensor<8xf32>) -> tensor<1xf32>
    %119 = stablehlo.reshape %118 : (tensor<1xf32>) -> tensor<f32>
    %120 = quantum.extract %28[ 1] : !quantum.reg -> !quantum.bit
    %121 = stablehlo.convert %119 : (tensor<f32>) -> tensor<f64>
    %extracted_54 = tensor.extract %121[] : tensor<f64>
    %out_qubits_55 = quantum.custom "RY"(%extracted_54) %120 : !quantum.bit
    %122 = stablehlo.convert %117 : (tensor<f32>) -> tensor<f64>
    %extracted_56 = tensor.extract %122[] : tensor<f64>
    %out_qubits_57 = quantum.custom "RZ"(%extracted_56) %out_qubits_55 : !quantum.bit
    %123 = stablehlo.convert %115 : (tensor<f32>) -> tensor<f64>
    %extracted_58 = tensor.extract %123[] : tensor<f64>
    %out_qubits_59 = quantum.custom "RY"(%extracted_58) %out_qubits_57 : !quantum.bit
    %124 = stablehlo.convert %113 : (tensor<f32>) -> tensor<f64>
    %extracted_60 = tensor.extract %124[] : tensor<f64>
    %out_qubits_61 = quantum.custom "RZ"(%extracted_60) %out_qubits_59 : !quantum.bit
    %out_qubits_62:2 = quantum.custom "CNOT"() %out_qubits_53, %out_qubits_61 : !quantum.bit, !quantum.bit
    %out_qubits_63:2 = quantum.custom "CNOT"() %out_qubits_62#1, %out_qubits_45 : !quantum.bit, !quantum.bit
    %out_qubits_64:2 = quantum.custom "CNOT"() %out_qubits_63#1, %out_qubits_37 : !quantum.bit, !quantum.bit
    %out_qubits_65:2 = quantum.custom "CNOT"() %out_qubits_64#1, %out_qubits_29 : !quantum.bit, !quantum.bit
    %out_qubits_66:2 = quantum.custom "CNOT"() %out_qubits_65#1, %out_qubits_21 : !quantum.bit, !quantum.bit
    %out_qubits_67:2 = quantum.custom "CNOT"() %out_qubits_66#1, %out_qubits_13 : !quantum.bit, !quantum.bit
    %out_qubits_68:2 = quantum.custom "CNOT"() %out_qubits_67#1, %out_qubits_5 : !quantum.bit, !quantum.bit
    %125 = stablehlo.convert %17 : (tensor<f32>) -> tensor<f64>
    %extracted_69 = tensor.extract %125[] : tensor<f64>
    %out_qubits_70 = quantum.custom "RZ"(%extracted_69) %out_qubits_68#0 : !quantum.bit
    %126 = stablehlo.convert %15 : (tensor<f32>) -> tensor<f64>
    %extracted_71 = tensor.extract %126[] : tensor<f64>
    %out_qubits_72 = quantum.custom "RY"(%extracted_71) %out_qubits_70 : !quantum.bit
    %127 = stablehlo.convert %13 : (tensor<f32>) -> tensor<f64>
    %extracted_73 = tensor.extract %127[] : tensor<f64>
    %out_qubits_74 = quantum.custom "RZ"(%extracted_73) %out_qubits_72 : !quantum.bit
    %128 = stablehlo.slice %arg0 [1:2, 4:5, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %129 = stablehlo.reshape %128 : (tensor<1x1x1xf32>) -> tensor<f32>
    %130 = stablehlo.slice %arg0 [1:2, 4:5, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %131 = stablehlo.reshape %130 : (tensor<1x1x1xf32>) -> tensor<f32>
    %132 = stablehlo.slice %arg0 [1:2, 4:5, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %133 = stablehlo.reshape %132 : (tensor<1x1x1xf32>) -> tensor<f32>
    %134 = stablehlo.convert %133 : (tensor<f32>) -> tensor<f64>
    %extracted_75 = tensor.extract %134[] : tensor<f64>
    %out_qubits_76 = quantum.custom "RZ"(%extracted_75) %out_qubits_66#0 : !quantum.bit
    %135 = stablehlo.convert %131 : (tensor<f32>) -> tensor<f64>
    %extracted_77 = tensor.extract %135[] : tensor<f64>
    %out_qubits_78 = quantum.custom "RY"(%extracted_77) %out_qubits_76 : !quantum.bit
    %136 = stablehlo.convert %129 : (tensor<f32>) -> tensor<f64>
    %extracted_79 = tensor.extract %136[] : tensor<f64>
    %out_qubits_80 = quantum.custom "RZ"(%extracted_79) %out_qubits_78 : !quantum.bit
    %137 = stablehlo.slice %arg0 [1:2, 0:1, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %138 = stablehlo.reshape %137 : (tensor<1x1x1xf32>) -> tensor<f32>
    %139 = stablehlo.slice %arg0 [1:2, 0:1, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %140 = stablehlo.reshape %139 : (tensor<1x1x1xf32>) -> tensor<f32>
    %141 = stablehlo.slice %arg0 [1:2, 0:1, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %142 = stablehlo.reshape %141 : (tensor<1x1x1xf32>) -> tensor<f32>
    %out_qubits_81:2 = quantum.custom "CNOT"() %out_qubits_68#1, %out_qubits_62#0 : !quantum.bit, !quantum.bit
    %143 = stablehlo.convert %142 : (tensor<f32>) -> tensor<f64>
    %extracted_82 = tensor.extract %143[] : tensor<f64>
    %out_qubits_83 = quantum.custom "RZ"(%extracted_82) %out_qubits_81#1 : !quantum.bit
    %144 = stablehlo.convert %140 : (tensor<f32>) -> tensor<f64>
    %extracted_84 = tensor.extract %144[] : tensor<f64>
    %out_qubits_85 = quantum.custom "RY"(%extracted_84) %out_qubits_83 : !quantum.bit
    %145 = stablehlo.convert %138 : (tensor<f32>) -> tensor<f64>
    %extracted_86 = tensor.extract %145[] : tensor<f64>
    %out_qubits_87 = quantum.custom "RZ"(%extracted_86) %out_qubits_85 : !quantum.bit
    %146 = stablehlo.slice %arg0 [1:2, 2:3, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %147 = stablehlo.reshape %146 : (tensor<1x1x1xf32>) -> tensor<f32>
    %148 = stablehlo.slice %arg0 [1:2, 2:3, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %149 = stablehlo.reshape %148 : (tensor<1x1x1xf32>) -> tensor<f32>
    %150 = stablehlo.slice %arg0 [1:2, 2:3, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %151 = stablehlo.reshape %150 : (tensor<1x1x1xf32>) -> tensor<f32>
    %152 = stablehlo.convert %151 : (tensor<f32>) -> tensor<f64>
    %extracted_88 = tensor.extract %152[] : tensor<f64>
    %out_qubits_89 = quantum.custom "RZ"(%extracted_88) %out_qubits_64#0 : !quantum.bit
    %153 = stablehlo.convert %149 : (tensor<f32>) -> tensor<f64>
    %extracted_90 = tensor.extract %153[] : tensor<f64>
    %out_qubits_91 = quantum.custom "RY"(%extracted_90) %out_qubits_89 : !quantum.bit
    %154 = stablehlo.convert %147 : (tensor<f32>) -> tensor<f64>
    %extracted_92 = tensor.extract %154[] : tensor<f64>
    %out_qubits_93 = quantum.custom "RZ"(%extracted_92) %out_qubits_91 : !quantum.bit
    %out_qubits_94:2 = quantum.custom "CNOT"() %out_qubits_87, %out_qubits_93 : !quantum.bit, !quantum.bit
    %out_qubits_95:2 = quantum.custom "CNOT"() %out_qubits_94#1, %out_qubits_80 : !quantum.bit, !quantum.bit
    %out_qubits_96:2 = quantum.custom "CNOT"() %out_qubits_95#1, %out_qubits_74 : !quantum.bit, !quantum.bit
    %out_qubits_97:2 = quantum.custom "CNOT"() %out_qubits_96#1, %out_qubits_94#0 : !quantum.bit, !quantum.bit
    %155 = stablehlo.convert %11 : (tensor<f32>) -> tensor<f64>
    %extracted_98 = tensor.extract %155[] : tensor<f64>
    %out_qubits_99 = quantum.custom "RZ"(%extracted_98) %out_qubits_97#1 : !quantum.bit
    %156 = stablehlo.convert %9 : (tensor<f32>) -> tensor<f64>
    %extracted_100 = tensor.extract %156[] : tensor<f64>
    %out_qubits_101 = quantum.custom "RY"(%extracted_100) %out_qubits_99 : !quantum.bit
    %157 = stablehlo.convert %7 : (tensor<f32>) -> tensor<f64>
    %extracted_102 = tensor.extract %157[] : tensor<f64>
    %out_qubits_103 = quantum.custom "RZ"(%extracted_102) %out_qubits_101 : !quantum.bit
    %158 = stablehlo.slice %arg0 [2:3, 3:4, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %159 = stablehlo.reshape %158 : (tensor<1x1x1xf32>) -> tensor<f32>
    %160 = stablehlo.slice %arg0 [2:3, 3:4, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %161 = stablehlo.reshape %160 : (tensor<1x1x1xf32>) -> tensor<f32>
    %162 = stablehlo.slice %arg0 [2:3, 3:4, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %163 = stablehlo.reshape %162 : (tensor<1x1x1xf32>) -> tensor<f32>
    %164 = stablehlo.slice %arg0 [1:2, 5:6, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %165 = stablehlo.reshape %164 : (tensor<1x1x1xf32>) -> tensor<f32>
    %166 = stablehlo.slice %arg0 [1:2, 5:6, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %167 = stablehlo.reshape %166 : (tensor<1x1x1xf32>) -> tensor<f32>
    %168 = stablehlo.slice %arg0 [1:2, 5:6, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %169 = stablehlo.reshape %168 : (tensor<1x1x1xf32>) -> tensor<f32>
    %170 = stablehlo.convert %169 : (tensor<f32>) -> tensor<f64>
    %extracted_104 = tensor.extract %170[] : tensor<f64>
    %out_qubits_105 = quantum.custom "RZ"(%extracted_104) %out_qubits_67#0 : !quantum.bit
    %171 = stablehlo.convert %167 : (tensor<f32>) -> tensor<f64>
    %extracted_106 = tensor.extract %171[] : tensor<f64>
    %out_qubits_107 = quantum.custom "RY"(%extracted_106) %out_qubits_105 : !quantum.bit
    %172 = stablehlo.convert %165 : (tensor<f32>) -> tensor<f64>
    %extracted_108 = tensor.extract %172[] : tensor<f64>
    %out_qubits_109 = quantum.custom "RZ"(%extracted_108) %out_qubits_107 : !quantum.bit
    %173 = stablehlo.slice %arg0 [1:2, 1:2, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %174 = stablehlo.reshape %173 : (tensor<1x1x1xf32>) -> tensor<f32>
    %175 = stablehlo.slice %arg0 [1:2, 1:2, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %176 = stablehlo.reshape %175 : (tensor<1x1x1xf32>) -> tensor<f32>
    %177 = stablehlo.slice %arg0 [1:2, 1:2, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %178 = stablehlo.reshape %177 : (tensor<1x1x1xf32>) -> tensor<f32>
    %179 = stablehlo.convert %178 : (tensor<f32>) -> tensor<f64>
    %extracted_110 = tensor.extract %179[] : tensor<f64>
    %out_qubits_111 = quantum.custom "RZ"(%extracted_110) %out_qubits_63#0 : !quantum.bit
    %180 = stablehlo.convert %176 : (tensor<f32>) -> tensor<f64>
    %extracted_112 = tensor.extract %180[] : tensor<f64>
    %out_qubits_113 = quantum.custom "RY"(%extracted_112) %out_qubits_111 : !quantum.bit
    %181 = stablehlo.convert %174 : (tensor<f32>) -> tensor<f64>
    %extracted_114 = tensor.extract %181[] : tensor<f64>
    %out_qubits_115 = quantum.custom "RZ"(%extracted_114) %out_qubits_113 : !quantum.bit
    %182 = stablehlo.slice %arg0 [1:2, 3:4, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %183 = stablehlo.reshape %182 : (tensor<1x1x1xf32>) -> tensor<f32>
    %184 = stablehlo.slice %arg0 [1:2, 3:4, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %185 = stablehlo.reshape %184 : (tensor<1x1x1xf32>) -> tensor<f32>
    %186 = stablehlo.slice %arg0 [1:2, 3:4, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %187 = stablehlo.reshape %186 : (tensor<1x1x1xf32>) -> tensor<f32>
    %188 = stablehlo.convert %187 : (tensor<f32>) -> tensor<f64>
    %extracted_116 = tensor.extract %188[] : tensor<f64>
    %out_qubits_117 = quantum.custom "RZ"(%extracted_116) %out_qubits_65#0 : !quantum.bit
    %189 = stablehlo.convert %185 : (tensor<f32>) -> tensor<f64>
    %extracted_118 = tensor.extract %189[] : tensor<f64>
    %out_qubits_119 = quantum.custom "RY"(%extracted_118) %out_qubits_117 : !quantum.bit
    %190 = stablehlo.convert %183 : (tensor<f32>) -> tensor<f64>
    %extracted_120 = tensor.extract %190[] : tensor<f64>
    %out_qubits_121 = quantum.custom "RZ"(%extracted_120) %out_qubits_119 : !quantum.bit
    %out_qubits_122:2 = quantum.custom "CNOT"() %out_qubits_115, %out_qubits_121 : !quantum.bit, !quantum.bit
    %out_qubits_123:2 = quantum.custom "CNOT"() %out_qubits_122#1, %out_qubits_109 : !quantum.bit, !quantum.bit
    %191 = stablehlo.convert %163 : (tensor<f32>) -> tensor<f64>
    %extracted_124 = tensor.extract %191[] : tensor<f64>
    %out_qubits_125 = quantum.custom "RZ"(%extracted_124) %out_qubits_123#0 : !quantum.bit
    %192 = stablehlo.convert %161 : (tensor<f32>) -> tensor<f64>
    %extracted_126 = tensor.extract %192[] : tensor<f64>
    %out_qubits_127 = quantum.custom "RY"(%extracted_126) %out_qubits_125 : !quantum.bit
    %193 = stablehlo.convert %159 : (tensor<f32>) -> tensor<f64>
    %extracted_128 = tensor.extract %193[] : tensor<f64>
    %out_qubits_129 = quantum.custom "RZ"(%extracted_128) %out_qubits_127 : !quantum.bit
    %out_qubits_130:2 = quantum.custom "CNOT"() %out_qubits_103, %out_qubits_129 : !quantum.bit, !quantum.bit
    %194 = stablehlo.slice %arg0 [2:3, 2:3, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %195 = stablehlo.reshape %194 : (tensor<1x1x1xf32>) -> tensor<f32>
    %196 = stablehlo.slice %arg0 [2:3, 2:3, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %197 = stablehlo.reshape %196 : (tensor<1x1x1xf32>) -> tensor<f32>
    %198 = stablehlo.slice %arg0 [2:3, 2:3, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %199 = stablehlo.reshape %198 : (tensor<1x1x1xf32>) -> tensor<f32>
    %200 = stablehlo.convert %199 : (tensor<f32>) -> tensor<f64>
    %extracted_131 = tensor.extract %200[] : tensor<f64>
    %out_qubits_132 = quantum.custom "RZ"(%extracted_131) %out_qubits_95#0 : !quantum.bit
    %201 = stablehlo.convert %197 : (tensor<f32>) -> tensor<f64>
    %extracted_133 = tensor.extract %201[] : tensor<f64>
    %out_qubits_134 = quantum.custom "RY"(%extracted_133) %out_qubits_132 : !quantum.bit
    %202 = stablehlo.convert %195 : (tensor<f32>) -> tensor<f64>
    %extracted_135 = tensor.extract %202[] : tensor<f64>
    %out_qubits_136 = quantum.custom "RZ"(%extracted_135) %out_qubits_134 : !quantum.bit
    %203 = stablehlo.slice %arg0 [2:3, 5:6, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %204 = stablehlo.reshape %203 : (tensor<1x1x1xf32>) -> tensor<f32>
    %205 = stablehlo.slice %arg0 [2:3, 5:6, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %206 = stablehlo.reshape %205 : (tensor<1x1x1xf32>) -> tensor<f32>
    %207 = stablehlo.slice %arg0 [2:3, 5:6, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %208 = stablehlo.reshape %207 : (tensor<1x1x1xf32>) -> tensor<f32>
    %209 = stablehlo.slice %arg0 [1:2, 7:8, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %210 = stablehlo.reshape %209 : (tensor<1x1x1xf32>) -> tensor<f32>
    %211 = stablehlo.slice %arg0 [1:2, 7:8, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %212 = stablehlo.reshape %211 : (tensor<1x1x1xf32>) -> tensor<f32>
    %213 = stablehlo.slice %arg0 [1:2, 7:8, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %214 = stablehlo.reshape %213 : (tensor<1x1x1xf32>) -> tensor<f32>
    %215 = stablehlo.convert %214 : (tensor<f32>) -> tensor<f64>
    %extracted_137 = tensor.extract %215[] : tensor<f64>
    %out_qubits_138 = quantum.custom "RZ"(%extracted_137) %out_qubits_81#0 : !quantum.bit
    %216 = stablehlo.convert %212 : (tensor<f32>) -> tensor<f64>
    %extracted_139 = tensor.extract %216[] : tensor<f64>
    %out_qubits_140 = quantum.custom "RY"(%extracted_139) %out_qubits_138 : !quantum.bit
    %217 = stablehlo.convert %210 : (tensor<f32>) -> tensor<f64>
    %extracted_141 = tensor.extract %217[] : tensor<f64>
    %out_qubits_142 = quantum.custom "RZ"(%extracted_141) %out_qubits_140 : !quantum.bit
    %out_qubits_143:2 = quantum.custom "CNOT"() %out_qubits_123#1, %out_qubits_142 : !quantum.bit, !quantum.bit
    %218 = stablehlo.convert %208 : (tensor<f32>) -> tensor<f64>
    %extracted_144 = tensor.extract %218[] : tensor<f64>
    %out_qubits_145 = quantum.custom "RZ"(%extracted_144) %out_qubits_143#0 : !quantum.bit
    %219 = stablehlo.convert %206 : (tensor<f32>) -> tensor<f64>
    %extracted_146 = tensor.extract %219[] : tensor<f64>
    %out_qubits_147 = quantum.custom "RY"(%extracted_146) %out_qubits_145 : !quantum.bit
    %220 = stablehlo.convert %204 : (tensor<f32>) -> tensor<f64>
    %extracted_148 = tensor.extract %220[] : tensor<f64>
    %out_qubits_149 = quantum.custom "RZ"(%extracted_148) %out_qubits_147 : !quantum.bit
    %out_qubits_150:2 = quantum.custom "CNOT"() %out_qubits_136, %out_qubits_149 : !quantum.bit, !quantum.bit
    %out_qubits_151:2 = quantum.custom "CNOT"() %out_qubits_150#1, %out_qubits_130#0 : !quantum.bit, !quantum.bit
    %221 = stablehlo.convert %5 : (tensor<f32>) -> tensor<f64>
    %extracted_152 = tensor.extract %221[] : tensor<f64>
    %out_qubits_153 = quantum.custom "RZ"(%extracted_152) %out_qubits_151#1 : !quantum.bit
    %222 = stablehlo.convert %3 : (tensor<f32>) -> tensor<f64>
    %extracted_154 = tensor.extract %222[] : tensor<f64>
    %out_qubits_155 = quantum.custom "RY"(%extracted_154) %out_qubits_153 : !quantum.bit
    %223 = stablehlo.convert %1 : (tensor<f32>) -> tensor<f64>
    %extracted_156 = tensor.extract %223[] : tensor<f64>
    %out_qubits_157 = quantum.custom "RZ"(%extracted_156) %out_qubits_155 : !quantum.bit
    %224 = stablehlo.slice %arg0 [3:4, 4:5, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %225 = stablehlo.reshape %224 : (tensor<1x1x1xf32>) -> tensor<f32>
    %226 = stablehlo.slice %arg0 [3:4, 4:5, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %227 = stablehlo.reshape %226 : (tensor<1x1x1xf32>) -> tensor<f32>
    %228 = stablehlo.slice %arg0 [3:4, 4:5, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %229 = stablehlo.reshape %228 : (tensor<1x1x1xf32>) -> tensor<f32>
    %230 = stablehlo.slice %arg0 [2:3, 7:8, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %231 = stablehlo.reshape %230 : (tensor<1x1x1xf32>) -> tensor<f32>
    %232 = stablehlo.slice %arg0 [2:3, 7:8, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %233 = stablehlo.reshape %232 : (tensor<1x1x1xf32>) -> tensor<f32>
    %234 = stablehlo.slice %arg0 [2:3, 7:8, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %235 = stablehlo.reshape %234 : (tensor<1x1x1xf32>) -> tensor<f32>
    %out_qubits_158:2 = quantum.custom "CNOT"() %out_qubits_143#1, %out_qubits_122#0 : !quantum.bit, !quantum.bit
    %236 = stablehlo.convert %235 : (tensor<f32>) -> tensor<f64>
    %extracted_159 = tensor.extract %236[] : tensor<f64>
    %out_qubits_160 = quantum.custom "RZ"(%extracted_159) %out_qubits_158#0 : !quantum.bit
    %237 = stablehlo.convert %233 : (tensor<f32>) -> tensor<f64>
    %extracted_161 = tensor.extract %237[] : tensor<f64>
    %out_qubits_162 = quantum.custom "RY"(%extracted_161) %out_qubits_160 : !quantum.bit
    %238 = stablehlo.convert %231 : (tensor<f32>) -> tensor<f64>
    %extracted_163 = tensor.extract %238[] : tensor<f64>
    %out_qubits_164 = quantum.custom "RZ"(%extracted_163) %out_qubits_162 : !quantum.bit
    %239 = stablehlo.slice %arg0 [2:3, 1:2, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %240 = stablehlo.reshape %239 : (tensor<1x1x1xf32>) -> tensor<f32>
    %241 = stablehlo.slice %arg0 [2:3, 1:2, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %242 = stablehlo.reshape %241 : (tensor<1x1x1xf32>) -> tensor<f32>
    %243 = stablehlo.slice %arg0 [2:3, 1:2, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %244 = stablehlo.reshape %243 : (tensor<1x1x1xf32>) -> tensor<f32>
    %245 = stablehlo.convert %244 : (tensor<f32>) -> tensor<f64>
    %extracted_165 = tensor.extract %245[] : tensor<f64>
    %out_qubits_166 = quantum.custom "RZ"(%extracted_165) %out_qubits_158#1 : !quantum.bit
    %246 = stablehlo.convert %242 : (tensor<f32>) -> tensor<f64>
    %extracted_167 = tensor.extract %246[] : tensor<f64>
    %out_qubits_168 = quantum.custom "RY"(%extracted_167) %out_qubits_166 : !quantum.bit
    %247 = stablehlo.convert %240 : (tensor<f32>) -> tensor<f64>
    %extracted_169 = tensor.extract %247[] : tensor<f64>
    %out_qubits_170 = quantum.custom "RZ"(%extracted_169) %out_qubits_168 : !quantum.bit
    %248 = stablehlo.slice %arg0 [2:3, 4:5, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %249 = stablehlo.reshape %248 : (tensor<1x1x1xf32>) -> tensor<f32>
    %250 = stablehlo.slice %arg0 [2:3, 4:5, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %251 = stablehlo.reshape %250 : (tensor<1x1x1xf32>) -> tensor<f32>
    %252 = stablehlo.slice %arg0 [2:3, 4:5, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %253 = stablehlo.reshape %252 : (tensor<1x1x1xf32>) -> tensor<f32>
    %254 = stablehlo.convert %253 : (tensor<f32>) -> tensor<f64>
    %extracted_171 = tensor.extract %254[] : tensor<f64>
    %out_qubits_172 = quantum.custom "RZ"(%extracted_171) %out_qubits_96#0 : !quantum.bit
    %255 = stablehlo.convert %251 : (tensor<f32>) -> tensor<f64>
    %extracted_173 = tensor.extract %255[] : tensor<f64>
    %out_qubits_174 = quantum.custom "RY"(%extracted_173) %out_qubits_172 : !quantum.bit
    %256 = stablehlo.convert %249 : (tensor<f32>) -> tensor<f64>
    %extracted_175 = tensor.extract %256[] : tensor<f64>
    %out_qubits_176 = quantum.custom "RZ"(%extracted_175) %out_qubits_174 : !quantum.bit
    %out_qubits_177:2 = quantum.custom "CNOT"() %out_qubits_170, %out_qubits_176 : !quantum.bit, !quantum.bit
    %out_qubits_178:2 = quantum.custom "CNOT"() %out_qubits_177#1, %out_qubits_164 : !quantum.bit, !quantum.bit
    %257 = stablehlo.convert %229 : (tensor<f32>) -> tensor<f64>
    %extracted_179 = tensor.extract %257[] : tensor<f64>
    %out_qubits_180 = quantum.custom "RZ"(%extracted_179) %out_qubits_178#0 : !quantum.bit
    %258 = stablehlo.convert %227 : (tensor<f32>) -> tensor<f64>
    %extracted_181 = tensor.extract %258[] : tensor<f64>
    %out_qubits_182 = quantum.custom "RY"(%extracted_181) %out_qubits_180 : !quantum.bit
    %259 = stablehlo.convert %225 : (tensor<f32>) -> tensor<f64>
    %extracted_183 = tensor.extract %259[] : tensor<f64>
    %out_qubits_184 = quantum.custom "RZ"(%extracted_183) %out_qubits_182 : !quantum.bit
    %out_qubits_185:2 = quantum.custom "CNOT"() %out_qubits_157, %out_qubits_184 : !quantum.bit, !quantum.bit
    %out_qubits_186:2 = quantum.custom "CNOT"() %out_qubits_185#1, %out_qubits_185#0 : !quantum.bit, !quantum.bit
    %260 = stablehlo.slice %arg0 [3:4, 1:2, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %261 = stablehlo.reshape %260 : (tensor<1x1x1xf32>) -> tensor<f32>
    %262 = stablehlo.slice %arg0 [3:4, 1:2, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %263 = stablehlo.reshape %262 : (tensor<1x1x1xf32>) -> tensor<f32>
    %264 = stablehlo.slice %arg0 [3:4, 1:2, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %265 = stablehlo.reshape %264 : (tensor<1x1x1xf32>) -> tensor<f32>
    %266 = stablehlo.slice %arg0 [2:3, 6:7, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %267 = stablehlo.reshape %266 : (tensor<1x1x1xf32>) -> tensor<f32>
    %268 = stablehlo.slice %arg0 [2:3, 6:7, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %269 = stablehlo.reshape %268 : (tensor<1x1x1xf32>) -> tensor<f32>
    %270 = stablehlo.slice %arg0 [2:3, 6:7, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %271 = stablehlo.reshape %270 : (tensor<1x1x1xf32>) -> tensor<f32>
    %272 = stablehlo.convert %271 : (tensor<f32>) -> tensor<f64>
    %extracted_187 = tensor.extract %272[] : tensor<f64>
    %out_qubits_188 = quantum.custom "RZ"(%extracted_187) %out_qubits_97#0 : !quantum.bit
    %273 = stablehlo.convert %269 : (tensor<f32>) -> tensor<f64>
    %extracted_189 = tensor.extract %273[] : tensor<f64>
    %out_qubits_190 = quantum.custom "RY"(%extracted_189) %out_qubits_188 : !quantum.bit
    %274 = stablehlo.convert %267 : (tensor<f32>) -> tensor<f64>
    %extracted_191 = tensor.extract %274[] : tensor<f64>
    %out_qubits_192 = quantum.custom "RZ"(%extracted_191) %out_qubits_190 : !quantum.bit
    %out_qubits_193:2 = quantum.custom "CNOT"() %out_qubits_130#1, %out_qubits_192 : !quantum.bit, !quantum.bit
    %out_qubits_194:2 = quantum.custom "CNOT"() %out_qubits_193#1, %out_qubits_177#0 : !quantum.bit, !quantum.bit
    %275 = stablehlo.convert %265 : (tensor<f32>) -> tensor<f64>
    %extracted_195 = tensor.extract %275[] : tensor<f64>
    %out_qubits_196 = quantum.custom "RZ"(%extracted_195) %out_qubits_194#1 : !quantum.bit
    %276 = stablehlo.convert %263 : (tensor<f32>) -> tensor<f64>
    %extracted_197 = tensor.extract %276[] : tensor<f64>
    %out_qubits_198 = quantum.custom "RY"(%extracted_197) %out_qubits_196 : !quantum.bit
    %277 = stablehlo.convert %261 : (tensor<f32>) -> tensor<f64>
    %extracted_199 = tensor.extract %277[] : tensor<f64>
    %out_qubits_200 = quantum.custom "RZ"(%extracted_199) %out_qubits_198 : !quantum.bit
    %278 = stablehlo.slice %arg0 [3:4, 5:6, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %279 = stablehlo.reshape %278 : (tensor<1x1x1xf32>) -> tensor<f32>
    %280 = stablehlo.slice %arg0 [3:4, 5:6, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %281 = stablehlo.reshape %280 : (tensor<1x1x1xf32>) -> tensor<f32>
    %282 = stablehlo.slice %arg0 [3:4, 5:6, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %283 = stablehlo.reshape %282 : (tensor<1x1x1xf32>) -> tensor<f32>
    %284 = stablehlo.convert %283 : (tensor<f32>) -> tensor<f64>
    %extracted_201 = tensor.extract %284[] : tensor<f64>
    %out_qubits_202 = quantum.custom "RZ"(%extracted_201) %out_qubits_151#0 : !quantum.bit
    %285 = stablehlo.convert %281 : (tensor<f32>) -> tensor<f64>
    %extracted_203 = tensor.extract %285[] : tensor<f64>
    %out_qubits_204 = quantum.custom "RY"(%extracted_203) %out_qubits_202 : !quantum.bit
    %286 = stablehlo.convert %279 : (tensor<f32>) -> tensor<f64>
    %extracted_205 = tensor.extract %286[] : tensor<f64>
    %out_qubits_206 = quantum.custom "RZ"(%extracted_205) %out_qubits_204 : !quantum.bit
    %out_qubits_207:2 = quantum.custom "CNOT"() %out_qubits_200, %out_qubits_206 : !quantum.bit, !quantum.bit
    %out_qubits_208:2 = quantum.custom "CNOT"() %out_qubits_207#1, %out_qubits_207#0 : !quantum.bit, !quantum.bit
    %287 = stablehlo.slice %arg0 [3:4, 2:3, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %288 = stablehlo.reshape %287 : (tensor<1x1x1xf32>) -> tensor<f32>
    %289 = stablehlo.slice %arg0 [3:4, 2:3, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %290 = stablehlo.reshape %289 : (tensor<1x1x1xf32>) -> tensor<f32>
    %291 = stablehlo.slice %arg0 [3:4, 2:3, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %292 = stablehlo.reshape %291 : (tensor<1x1x1xf32>) -> tensor<f32>
    %out_qubits_209:2 = quantum.custom "CNOT"() %out_qubits_178#1, %out_qubits_150#0 : !quantum.bit, !quantum.bit
    %293 = stablehlo.convert %292 : (tensor<f32>) -> tensor<f64>
    %extracted_210 = tensor.extract %293[] : tensor<f64>
    %out_qubits_211 = quantum.custom "RZ"(%extracted_210) %out_qubits_209#1 : !quantum.bit
    %294 = stablehlo.convert %290 : (tensor<f32>) -> tensor<f64>
    %extracted_212 = tensor.extract %294[] : tensor<f64>
    %out_qubits_213 = quantum.custom "RY"(%extracted_212) %out_qubits_211 : !quantum.bit
    %295 = stablehlo.convert %288 : (tensor<f32>) -> tensor<f64>
    %extracted_214 = tensor.extract %295[] : tensor<f64>
    %out_qubits_215 = quantum.custom "RZ"(%extracted_214) %out_qubits_213 : !quantum.bit
    %296 = stablehlo.slice %arg0 [3:4, 6:7, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %297 = stablehlo.reshape %296 : (tensor<1x1x1xf32>) -> tensor<f32>
    %298 = stablehlo.slice %arg0 [3:4, 6:7, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %299 = stablehlo.reshape %298 : (tensor<1x1x1xf32>) -> tensor<f32>
    %300 = stablehlo.slice %arg0 [3:4, 6:7, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %301 = stablehlo.reshape %300 : (tensor<1x1x1xf32>) -> tensor<f32>
    %302 = stablehlo.convert %301 : (tensor<f32>) -> tensor<f64>
    %extracted_216 = tensor.extract %302[] : tensor<f64>
    %out_qubits_217 = quantum.custom "RZ"(%extracted_216) %out_qubits_194#0 : !quantum.bit
    %303 = stablehlo.convert %299 : (tensor<f32>) -> tensor<f64>
    %extracted_218 = tensor.extract %303[] : tensor<f64>
    %out_qubits_219 = quantum.custom "RY"(%extracted_218) %out_qubits_217 : !quantum.bit
    %304 = stablehlo.convert %297 : (tensor<f32>) -> tensor<f64>
    %extracted_220 = tensor.extract %304[] : tensor<f64>
    %out_qubits_221 = quantum.custom "RZ"(%extracted_220) %out_qubits_219 : !quantum.bit
    %out_qubits_222:2 = quantum.custom "CNOT"() %out_qubits_215, %out_qubits_221 : !quantum.bit, !quantum.bit
    %out_qubits_223:2 = quantum.custom "CNOT"() %out_qubits_222#1, %out_qubits_222#0 : !quantum.bit, !quantum.bit
    %305 = stablehlo.slice %arg0 [3:4, 3:4, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %306 = stablehlo.reshape %305 : (tensor<1x1x1xf32>) -> tensor<f32>
    %307 = stablehlo.slice %arg0 [3:4, 3:4, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %308 = stablehlo.reshape %307 : (tensor<1x1x1xf32>) -> tensor<f32>
    %309 = stablehlo.slice %arg0 [3:4, 3:4, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %310 = stablehlo.reshape %309 : (tensor<1x1x1xf32>) -> tensor<f32>
    %311 = stablehlo.convert %310 : (tensor<f32>) -> tensor<f64>
    %extracted_224 = tensor.extract %311[] : tensor<f64>
    %out_qubits_225 = quantum.custom "RZ"(%extracted_224) %out_qubits_193#0 : !quantum.bit
    %312 = stablehlo.convert %308 : (tensor<f32>) -> tensor<f64>
    %extracted_226 = tensor.extract %312[] : tensor<f64>
    %out_qubits_227 = quantum.custom "RY"(%extracted_226) %out_qubits_225 : !quantum.bit
    %313 = stablehlo.convert %306 : (tensor<f32>) -> tensor<f64>
    %extracted_228 = tensor.extract %313[] : tensor<f64>
    %out_qubits_229 = quantum.custom "RZ"(%extracted_228) %out_qubits_227 : !quantum.bit
    %314 = stablehlo.slice %arg0 [3:4, 7:8, 2:3] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %315 = stablehlo.reshape %314 : (tensor<1x1x1xf32>) -> tensor<f32>
    %316 = stablehlo.slice %arg0 [3:4, 7:8, 1:2] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %317 = stablehlo.reshape %316 : (tensor<1x1x1xf32>) -> tensor<f32>
    %318 = stablehlo.slice %arg0 [3:4, 7:8, 0:1] : (tensor<4x8x3xf32>) -> tensor<1x1x1xf32>
    %319 = stablehlo.reshape %318 : (tensor<1x1x1xf32>) -> tensor<f32>
    %320 = stablehlo.convert %319 : (tensor<f32>) -> tensor<f64>
    %extracted_230 = tensor.extract %320[] : tensor<f64>
    %out_qubits_231 = quantum.custom "RZ"(%extracted_230) %out_qubits_209#0 : !quantum.bit
    %321 = stablehlo.convert %317 : (tensor<f32>) -> tensor<f64>
    %extracted_232 = tensor.extract %321[] : tensor<f64>
    %out_qubits_233 = quantum.custom "RY"(%extracted_232) %out_qubits_231 : !quantum.bit
    %322 = stablehlo.convert %315 : (tensor<f32>) -> tensor<f64>
    %extracted_234 = tensor.extract %322[] : tensor<f64>
    %out_qubits_235 = quantum.custom "RZ"(%extracted_234) %out_qubits_233 : !quantum.bit
    %out_qubits_236:2 = quantum.custom "CNOT"() %out_qubits_229, %out_qubits_235 : !quantum.bit, !quantum.bit
    %out_qubits_237:2 = quantum.custom "CNOT"() %out_qubits_236#1, %out_qubits_236#0 : !quantum.bit, !quantum.bit
    %323 = quantum.namedobs %out_qubits_186#1[ PauliZ] : !quantum.obs
    %324 = quantum.expval %323 : f64
    %from_elements = tensor.from_elements %324 : tensor<f64>
    %325 = quantum.insert %28[ 0], %out_qubits_186#1 : !quantum.reg, !quantum.bit
    %326 = quantum.insert %325[ 1], %out_qubits_208#1 : !quantum.reg, !quantum.bit
    %327 = quantum.insert %326[ 2], %out_qubits_223#1 : !quantum.reg, !quantum.bit
    %328 = quantum.insert %327[ 3], %out_qubits_237#1 : !quantum.reg, !quantum.bit
    %329 = quantum.insert %328[ 4], %out_qubits_186#0 : !quantum.reg, !quantum.bit
    %330 = quantum.insert %329[ 5], %out_qubits_208#0 : !quantum.reg, !quantum.bit
    %331 = quantum.insert %330[ 6], %out_qubits_223#0 : !quantum.reg, !quantum.bit
    %332 = quantum.insert %331[ 7], %out_qubits_237#0 : !quantum.reg, !quantum.bit
    quantum.dealloc %332 : !quantum.reg
    quantum.device_release
    return %from_elements : tensor<f64>
  }
  func.func private @softplus(%arg0: tensor<f64>) -> tensor<f64> attributes {llvm.linkage = #llvm.linkage<internal>} {
    %cst = stablehlo.constant dense<0.000000e+00> : tensor<f64>
    %0 = stablehlo.maximum %arg0, %cst : tensor<f64>
    %1 = stablehlo.subtract %arg0, %cst : tensor<f64>
    %2 = stablehlo.compare  NE, %1, %1,  FLOAT : (tensor<f64>, tensor<f64>) -> tensor<i1>
    %3 = stablehlo.add %arg0, %cst : tensor<f64>
    %4 = stablehlo.abs %1 : tensor<f64>
    %5 = stablehlo.negate %4 : tensor<f64>
    %6 = stablehlo.exponential %5 : tensor<f64>
    %7 = stablehlo.log_plus_one %6 : tensor<f64>
    %8 = stablehlo.add %0, %7 : tensor<f64>
    %9 = stablehlo.select %2, %3, %8 : tensor<i1>, tensor<f64>
    return %9 : tensor<f64>
  }
  func.func private @_sample_loss(%arg0: tensor<4x8x3xf32>, %arg1: tensor<f32>, %arg2: tensor<f32>, %arg3: tensor<8xf32>, %arg4: tensor<f32>, %arg5: tensor<f32>) -> tensor<f64> attributes {llvm.linkage = #llvm.linkage<internal>} {
    %0 = call @qnode_forward_0(%arg0, %arg3) : (tensor<4x8x3xf32>, tensor<8xf32>) -> tensor<f64>
    %1 = stablehlo.convert %arg2 : (tensor<f32>) -> tensor<f64>
    %2 = stablehlo.multiply %1, %0 : tensor<f64>
    %3 = stablehlo.convert %arg1 : (tensor<f32>) -> tensor<f64>
    %4 = stablehlo.add %2, %3 : tensor<f64>
    %5 = stablehlo.convert %arg4 : (tensor<f32>) -> tensor<f64>
    %6 = stablehlo.convert %arg5 : (tensor<f32>) -> tensor<f64>
    %7 = call @softplus_2(%4) : (tensor<f64>) -> tensor<f64>
    %8 = stablehlo.multiply %5, %4 : tensor<f64>
    %9 = stablehlo.subtract %7, %8 : tensor<f64>
    %10 = stablehlo.multiply %6, %9 : tensor<f64>
    return %10 : tensor<f64>
  }
  func.func private @softplus_2(%arg0: tensor<f64>) -> tensor<f64> attributes {llvm.linkage = #llvm.linkage<internal>} {
    %cst = stablehlo.constant dense<0.000000e+00> : tensor<f64>
    %0 = stablehlo.maximum %arg0, %cst : tensor<f64>
    %1 = stablehlo.subtract %arg0, %cst : tensor<f64>
    %2 = stablehlo.compare  NE, %1, %1,  FLOAT : (tensor<f64>, tensor<f64>) -> tensor<i1>
    %3 = stablehlo.add %arg0, %cst : tensor<f64>
    %4 = stablehlo.abs %1 : tensor<f64>
    %5 = stablehlo.negate %4 : tensor<f64>
    %6 = stablehlo.exponential %5 : tensor<f64>
    %7 = stablehlo.log_plus_one %6 : tensor<f64>
    %8 = stablehlo.add %0, %7 : tensor<f64>
    %9 = stablehlo.select %2, %3, %8 : tensor<i1>, tensor<f64>
    return %9 : tensor<f64>
  }
  func.func @setup() {
    quantum.init
    return
  }
  func.func @teardown() {
    quantum.finalize
    return
  }
}